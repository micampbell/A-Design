;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; I-AGENTS OR INSTANTIATION-AGENTS
;;; Agents are called from instantiate-conceptual in instantiate.lisp.
;;;
;;; Agents are passed a design with blanks (nil's) in the compoent space.
;;; 
;;; It returns just the name of the design with the blank's filled for the
;;; component and the i-agent spot where it puts it's name to correspond to 
;;; the component it added.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun agent-1-upper-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	   (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	   (candidates nil (cond ((or (null max-threshold) 
				      (>= (nth datum-pos (second comp)) 
					  max-threshold))
				  (cons comp candidates))
				 (t candidates)))
	   (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 0 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-1-upper-mg-most-used-datum))
	    concept))))))


(defun agent-1-middle-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	   (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	   (max-threshold (cond (datum-pos 
				 (second (nth datum-pos file-vars)))))
	   (candidates nil (cond ((or (and (null min-threshold) 
					   (null max-threshold))
				      (and (>= (nth datum-pos (second comp)) 
					       min-threshold) 
					   (<= (nth datum-pos (second comp)) 
					       max-threshold))) 
				  (cons comp candidates))
				 (t candidates)))
	   (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 0 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-1-middle-mg-most-used-datum))
	    concept))))))


(defun agent-1-lower-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	   (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	   (candidates nil (cond ((or (null min-threshold)
				      (<= (nth datum-pos (second comp)) 
					  min-threshold))
				  (cons comp candidates))
				 (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 0 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-1-lower-mg-most-used-datum))
	    concept))))))


(defun agent-2-upper-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	   (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null max-threshold) 
				     (>= (nth datum-pos (second comp)) 
					 max-threshold))
				 (cons comp candidates))
				 (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 1 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-2-upper-mg-most-used-datum))
	    concept))))))


(defun agent-2-middle-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (and (null min-threshold) (null max-threshold))
				     (and (>= (nth datum-pos (second comp)) 
					      min-threshold) 
					  (<= (nth datum-pos (second comp)) 
					      max-threshold))) 
				(cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 1 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-2-middle-mg-most-used-datum))
	    concept))))))


(defun agent-2-lower-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null min-threshold)
				     (<= (nth datum-pos (second comp)) 
					 min-threshold))
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 1 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-2-lower-mg-most-used-datum))
	    concept))))))


(defun agent-3-upper-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null max-threshold)
				     (>= (nth datum-pos (second comp)) 
					 max-threshold))
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 2 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-3-upper-mg-most-used-datum))
	    concept))))))


(defun agent-3-middle-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (and (null min-threshold) (null max-threshold)) 
				     (and (>= (nth datum-pos (second comp)) 
					      min-threshold) 
					  (<= (nth datum-pos (second comp)) 
					      max-threshold))) 
				(cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 2 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-3-middle-mg-most-used-datum))
	    concept))))))


(defun agent-3-lower-mg-most-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'max)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null min-threshold)
				     (<= (nth datum-pos (second comp)) 
					 min-threshold))
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 2 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-3-lower-mg-most-used-datum))
	    concept))))))


(defun agent-1-upper-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null max-threshold)
				     (>= (nth datum-pos (second comp)) 
					 max-threshold))
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 0 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-1-upper-mg-least-used-datum))
	    concept))))))


(defun agent-1-middle-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (and (null min-threshold) (null max-threshold))
				     (and (>= (nth datum-pos (second comp)) 
					      min-threshold) 
					  (<= (nth datum-pos (second comp)) 
					      max-threshold))) 
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 0 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-1-middle-mg-least-used-datum))
	    concept))))))


(defun agent-1-lower-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	   (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	   (candidates nil (cond ((or (null min-threshold)
				      (<= (nth datum-pos (second comp)) 
					  min-threshold))
				  (cons comp candidates))
				 (t candidates)))
	   (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 0 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-1-lower-mg-least-used-datum))
	    concept))))))


(defun agent-2-upper-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null max-threshold)
				     (>= (nth datum-pos (second comp)) 
					 max-threshold))
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 1 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-2-upper-mg-least-used-datum))
	    concept))))))


(defun agent-2-middle-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (and (null min-threshold) (null max-threshold)) 
				     (and (>= (nth datum-pos (second comp)) 
					      min-threshold) 
					  (<= (nth datum-pos (second comp)) 
					      max-threshold))) 
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 1 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-2-middle-mg-least-used-datum))
	    concept))))))


(defun agent-2-lower-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null min-threshold)
				     (<= (nth datum-pos (second comp)) 
					 min-threshold))
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 1 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-2-lower-mg-least-used-datum))
	    concept))))))


(defun agent-3-upper-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (null max-threshold)
				     (>= (nth datum-pos (second comp)) 
					 max-threshold))
				 (cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 2 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-3-upper-mg-least-used-datum))
	    concept))))))


(defun agent-3-middle-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	  (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	  (max-threshold (cond (datum-pos (second (nth datum-pos file-vars)))))
	  (candidates nil (cond ((or (and (null min-threshold) (null max-threshold)) 
				     (and (>= (nth datum-pos (second comp)) 
					 min-threshold) 
				     (<= (nth datum-pos (second comp)) 
					 max-threshold))) 
				(cons comp candidates))
			       (t candidates)))
	  (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 2 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-3-middle-mg-least-used-datum))
	    concept))))))


(defun agent-3-lower-mg-least-used-datum (concept)
  (let* ((i (position nil (sc-components concept)))
	 (eb (nth i (sc-embodiments concept)))
	 (datum-pos (datum-position eb i concept :choose 'min)))
    (with-open-file 
     (iofile (get-component-file eb) :direction :io :if-exists :overwrite) 
     (do* ((file-vars (get-or-initialize-comp-file-vars iofile))
	   (min-threshold (cond (datum-pos (car (nth datum-pos file-vars)))))
	   (candidates nil (cond ((or (null min-threshold) 
				      (<= (nth datum-pos (second comp)) 
				      min-threshold)) (cons comp candidates))
				 (t candidates)))
	   (comp (read iofile nil nil) (read iofile nil nil)))
	 ((null comp) 
	  (let ((comp (find-component candidates 1 2 'inverse)))
	    (setf (sc-components concept) 
		  (mod-list (sc-components concept) i comp))
	    (setf (sc-i-agents concept)
		  (mod-list (sc-i-agents concept) i 
			    'agent-3-lower-mg-least-used-datum))
	    concept))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; I-AGENT HELPER FUNCTIONS
;;; THESE FUNCTIONS ARE EXECUTED BY THE I-AGENTS IN CHOOSING COMPONENTS FOR
;;; AN EMBODIMENT.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun datum-position (eb num concept &key choose)
  (let* ((freqs (mapcar #'(lambda (x) 
			    (r-count
			     (intern (make-symbol (format nil "~A_~D" 
							  (string x) num)))
			     (sc-behavior-eq concept) 
			     :test 'equal))
			(eb-data (eval eb))))
	 (chosen (cond (freqs (apply choose freqs)))))
    (cond ((= 1 (count chosen freqs)) (position chosen freqs))
	  ((zerop (count chosen freqs)) nil)
	  (t
	   (do ((index (random (length freqs)) (random (length freqs))))
	       ((= (nth index freqs) chosen) index))))))


(defun get-component-file (eb)
  (do* ((filename (string eb) (string-right-trim (string last-char) filename))
	(last-char (char filename (1- (length filename)))
		   (char filename (1- (length filename)))))
      ((alpha-char-p last-char)
       (make-pathname :directory *library-dir*
		      :name (string-downcase filename)
		      :type "comps"))))


(defun get-or-initialize-comp-file-vars (iofile)
  (let ((vars (multiple-value-list (read-line iofile))))
    (cond 
     ((consp (car (read-from-string (car vars) nil)))
      (read-from-string (car vars)))
     (t
      (do* ((line vars (multiple-value-list (read-line iofile nil 
						       (values-list '("" t)))))
	    (saved-file (list (car line)) (backcons (car line) saved-file))
	    (data-list
	     (cond ((consp (read-from-string (car line) nil)) 
		    (mapcar 'list (second (read-from-string (car line)))))
		   (t nil))
	     (cond ((and data-list (consp (read-from-string (car line) nil)))
		    (mapcar #'(lambda (x y) (cons x y)) 
			    (second (read-from-string (car line)))
			    data-list))
		   ((consp (read-from-string (car line) nil))
		    (mapcar 'list (second (read-from-string (car line)))))
		   (t data-list))))
	  ((cadr line)
	   (let* ((s-data-list (mapcar #'(lambda (x) (sort x '<)) data-list))
		  (first-third (truncate (length (car s-data-list)) 3))
		  (second-third (truncate (* 2 (length (car s-data-list))) 3))
		  (cutoffs (mapcar #'(lambda (x) (list (nth first-third x)
						       (nth second-third x)))
				   s-data-list)))
	     (file-position iofile 0)
	     (princ (format nil "~A~%" cutoffs) iofile)
	     (terpri iofile)
	     (mapcar #'(lambda (x) (write-line x iofile)) saved-file)
	     (file-position iofile 0)
	     (read-from-string (read-line iofile)))))))))


(defun find-component (cands pos1 pos2 method &optional rand-num nums)
  (cond ((null rand-num) 
	 (cond 
	  ((equal method 'inverse)
	   (find-component 
	    cands pos1 pos2 nil
	    (random (apply '+ (mapcar #'(lambda (x) 
					  (/ (nth pos2 (nth pos1 x)))) cands)))
	    (mapcar #'(lambda (x) (/ (nth pos2 (nth pos1 x)))) cands)))))
	((> (- rand-num (car nums)) 0) 
	 (find-component (cdr cands) pos1 pos2  nil
			 (- rand-num (car nums)) (cdr nums)))
	(t (car cands))))

